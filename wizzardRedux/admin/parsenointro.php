<?php

/* ------------------------------------------------------------------------------------
Internal test to see if the No-Intro pages can be traversed reasonably
Original code by Matt Nadareski (darksabre76)

Requires
	auto		Set to 1 if a new no-intro mapping needs to be created
	
TODO: Match redumps as well as good and scene
------------------------------------------------------------------------------------ */

ini_set('max_execution_time', 6000); // Set the execution time higher because DATs can be big

// auto means create the mapping
if (isset($_GET["auto"]) && $_GET["auto"] == "1")
{
	$query = file("http://datomatic.no-intro.org/?page=download");
	
	$handle = fopen("../css/nointro.php", "w");
	fwrite($handle, "<?php\n\n".
			"/*\nAuto-generated by parsenointro.php\n*/\n\n".
			"// Mapping for No-Intro systems to ids\n".
			"\$no_intro_ids = array (\n");
	foreach ($query as $line)
	{
		if (strpos($line, "index.php?page=search&s="))
		{
			$line = trim($line);
			preg_match("/<b><a href=\"index\.php\?page=search&s=([0-9]+).*>(.*)<\/a><\/b>/", $line, $xml);
			fwrite($handle, "\t'".$xml[2]."' => ".$xml[1].",\n");
		}
	}
	fwrite($handle, ")\n\n?>");
	fclose($handle);
}
// Try and get rom information direct from the no-intro pages. (Rollback?)
else
{
	echo "<a href='page=parsenointro&auto=1'>Auto-generate no-intro name to system mapping</a><br/><br/>\n";
	
	$gameid = 1; $maxid = 2;
	$errorpage = false;
	$roms = array(); // name, size, crc, md5, sha1
	while (!$errorpage)
	{
		// Retrieve the page information
		$query = get_data("http://datomatic.no-intro.org/index.php?page=show_record&s=28&n=".str_pad($gameid, 4, "0", STR_PAD_LEFT));
				
		// The error page case, it means time to stop the cycle
		// This could result in too many page request too... not sure though
		if ($query == "" || strpos($query, "I am too busy for this!") || $gameid > $maxid)
		{
			$errorpage = true;
			break;
		}
		
		// Create all necessary regex patterns
		$regex_romname = "<tr class=\"romname_section\">\s+<td>\s+&nbsp;(.+?)<br \/>&nbsp;\s+<\/td>";
		$regex_romsize = "<tr>\s+<td class=\"TableTitle\" colspan=\"3\">ROM data<\/td>\s+<\/tr>\s+<tr>\s+<td.*?>Size:<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		$regex_deccrc = "<tr>\s+<td class=\"TableData\".*?>\s*Decrypted CRC32:\s*<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		$regex_decmd5 = "<tr>\s+<td class=\"TableData\".*?>\s*Decrypted MD5:\s*<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		$regex_decsha1 = "<tr>\s+<td class=\"TableData\".*?>\s*Decrypted SHA-1:\s*<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		$regex_enccrc = "<tr>\s+<td class=\"TableData\".*?>\s*Encrypted CRC32:\s*<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		$regex_encmd5 = "<tr>\s+<td class=\"TableData\".*?>\s*Encrypted MD5:\s*<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		$regex_encsha1 = "<tr>\s+<td class=\"TableData\".*?>\s*Encrypted SHA-1:\s*<\/td>\s+<td class=\"TableData\">(.*?)<\/td>\s+<\/tr>";
		
		// Get initial rom information
		$regex_rominfo = "/".
			$regex_romname.".*?".
			$regex_romsize.".*?".
			$regex_deccrc.".*?".
			$regex_decmd5.".*?".
			$regex_decsha1.".*?".
			//$regex_enccrc.".*?".
			//$regex_encmd5.".*?".
			//$regex_encsha1.".*?".
		"/s";
		
		preg_match($regex_rominfo, $query, $rominfo);
		unset($rominfo[0]);
		
		// Strip out the extension and number
		$rominfo[1] = preg_replace("/\d{4} - (.*?)\..*/", "$1", $rominfo[1]);
		
		// Add the currently accepted rom to the array
		$roms[] = array($rominfo[1], $rominfo[2], $rominfo[3], $rominfo[4], $rominfo[5]);
		
		// To make sure we don't match initial rom information, remove everything before Scene releases
		$query = explode("Scene releases", $query);
		
		// If there are no scene releases, go to the next page
		if ($query[1] === NULL)
		{
			continue;
		}
		$query = $query[1];
		
		// Create all necessary regex patterns
		$regex_dir = "<tr.*?>\s+<td width=\"104px\">\s+Directory:\s+<\/td>\s+<td>\s+(.*?)\s+<\/td>\s+<\/tr>";
		$regex_nfo = "<tr>\s+<td class=\"TableData\" width=\"104px\">\s+NFO File:\s+<\/td>\s+<td class=\"TableData\">\s+(.*?)\s+<\/td>\s+<\/tr>";
		$regex_group = "<tr>\s+<td class=\"TableData\" width=\"104px\">\s+Group:\s+<\/td>\s+<td class=\"TableData\">\s+(.*?)\s+<\/td>\s+<\/tr>";
		$regex_released = "<tr>\s+<td class=\"TableData\" width=\"104px\">\s+Released:\s+<\/td>\s+<td class=\"TableData\">\s+(.*?)\s+<\/td>\s+<\/tr>";
		
		$regex_sceneinfo = "/".
			$regex_dir.".*?".
			$regex_nfo.".*?".
			$regex_group.".*?".
			$regex_released.".*?".
			$regex_deccrc.".*?".
			$regex_decmd5.".*?".
		"/s";
		
		preg_match_all($regex_sceneinfo, $query, $sceneinfo);
		
		$scenenew = array();
		for ($index = 0; $index < sizeof($sceneinfo[0]); $index++)
		{
			$scenenew[] = array(
					trim($sceneinfo[1][$index]),
					trim($sceneinfo[2][$index]),
					trim($sceneinfo[3][$index]),
					trim($sceneinfo[4][$index]),
					trim($sceneinfo[5][$index]),
					trim($sceneinfo[6][$index]),
			);
		}
		$sceneinfo = $scenenew;
		unset($scenenew);
		
		// Add all of the scene roms to the array
		foreach ($sceneinfo as $scene)
		{
			$roms[] = array($scene[3]."_".$scene[0], $rominfo[2], $scene[4], $scene[5], "");
		}
		
		// Increment the game pointer
		$gameid++;
		
		// Wait 5 seconds to avoid flooding the server
		sleep(5);
	}
	
	echo "Error page hit or ran out of numbers.<br/>";
	var_dump($roms);
}

?>